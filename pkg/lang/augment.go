package lang

import (
	"fmt"

	"github.com/agext/levenshtein"
	"github.com/hashicorp/hcl/v2"
	"github.com/hashicorp/hcl/v2/ext/customdecode"
	"github.com/hashicorp/hcl/v2/hclsyntax"
	"github.com/zclconf/go-cty/cty"
	"github.com/zclconf/go-cty/cty/convert"
	"github.com/zclconf/go-cty/cty/function"
)

// nameSuggestion tries to find a name from the given slice of suggested names
// that is close to the given name and returns it if found. If no suggestion
// is close enough, returns the empty string.
//
// The suggestions are tried in order, so earlier suggestions take precedence
// if the given string is similar to two or more suggestions.
//
// This function is intended to be used with a relatively-small number of
// suggestions. It's not optimized for hundreds or thousands of them.
func nameSuggestion(given string, suggestions []string) string {
	for _, suggestion := range suggestions {
		dist := levenshtein.Distance(given, suggestion, nil)
		if dist < 3 { // threshold determined experimentally
			return suggestion
		}
	}
	return ""
}

// FunctionCallDiagExtra is an interface implemented by the value in the "Extra"
// field of some diagnostics returned by FunctionCallExpr.Value, giving
// cooperating callers access to some machine-readable information about the
// call that a diagnostic relates to.
type FunctionCallDiagExtra interface {
	// CalledFunctionName returns the name of the function being called at
	// the time the diagnostic was generated, if any. Returns an empty string
	// if there is no known called function.
	CalledFunctionName() string

	// FunctionCallError returns the error value returned by the implementation
	// of the function being called, if any. Returns nil if the diagnostic was
	// not returned in response to a call error.
	//
	// Some errors related to calling functions are generated by HCL itself
	// rather than by the underlying function, in which case this method
	// will return nil.
	FunctionCallError() error
}

type functionCallDiagExtra struct {
	calledFunctionName string
	functionCallError  error
}

func Value(ctx *hcl.EvalContext, e *hclsyntax.FunctionCallExpr) (cty.Value, hcl.Diagnostics) {
	var diags hcl.Diagnostics

	var f function.Function
	exists := false
	hasNonNilMap := false
	thisCtx := ctx
	for thisCtx != nil {
		if thisCtx.Functions == nil {
			thisCtx = thisCtx.Parent()
			continue
		}
		hasNonNilMap = true
		f, exists = thisCtx.Functions[e.Name]
		if exists {
			break
		}
		thisCtx = thisCtx.Parent()
	}

	if !exists {
		if !hasNonNilMap {
			return cty.DynamicVal, hcl.Diagnostics{
				{
					Severity:    hcl.DiagError,
					Summary:     "Function calls not allowed",
					Detail:      "Functions may not be called here.",
					Subject:     e.Range().Ptr(),
					Expression:  e,
					EvalContext: ctx,
				},
			}
		}

		avail := make([]string, 0, len(ctx.Functions))
		for name := range ctx.Functions {
			avail = append(avail, name)
		}
		suggestion := nameSuggestion(e.Name, avail)
		if suggestion != "" {
			suggestion = fmt.Sprintf(" Did you mean %q?", suggestion)
		}

		return cty.DynamicVal, hcl.Diagnostics{
			{
				Severity:    hcl.DiagError,
				Summary:     "Call to unknown function",
				Detail:      fmt.Sprintf("There is no function named %q.%s", e.Name, suggestion),
				Subject:     &e.NameRange,
				Context:     e.Range().Ptr(),
				Expression:  e,
				EvalContext: ctx,
			},
		}
	}

	diagExtra := functionCallDiagExtra{
		calledFunctionName: e.Name,
	}

	params := f.Params()
	varParam := f.VarParam()

	args := e.Args
	if e.ExpandFinal {
		if len(args) < 1 {
			// should never happen if the parser is behaving
			panic("ExpandFinal set on function call with no arguments")
		}
		expandExpr := args[len(args)-1]
		expandVal, expandDiags := expandExpr.Value(ctx)
		diags = append(diags, expandDiags...)
		if expandDiags.HasErrors() {
			return cty.DynamicVal, diags
		}

		switch {
		case expandVal.Type().Equals(cty.DynamicPseudoType):
			if expandVal.IsNull() {
				diags = append(diags, &hcl.Diagnostic{
					Severity:    hcl.DiagError,
					Summary:     "Invalid expanding argument value",
					Detail:      "The expanding argument (indicated by ...) must not be null.",
					Subject:     expandExpr.Range().Ptr(),
					Context:     e.Range().Ptr(),
					Expression:  expandExpr,
					EvalContext: ctx,
					Extra:       &diagExtra,
				})
				return cty.DynamicVal, diags
			}
			return cty.DynamicVal, diags
		case expandVal.Type().IsTupleType() || expandVal.Type().IsListType() || expandVal.Type().IsSetType():
			if expandVal.IsNull() {
				diags = append(diags, &hcl.Diagnostic{
					Severity:    hcl.DiagError,
					Summary:     "Invalid expanding argument value",
					Detail:      "The expanding argument (indicated by ...) must not be null.",
					Subject:     expandExpr.Range().Ptr(),
					Context:     e.Range().Ptr(),
					Expression:  expandExpr,
					EvalContext: ctx,
					Extra:       &diagExtra,
				})
				return cty.DynamicVal, diags
			}
			if !expandVal.IsKnown() {
				return cty.DynamicVal, diags
			}

			// When expanding arguments from a collection, we must first unmark
			// the collection itself, and apply any marks directly to the
			// elements. This ensures that marks propagate correctly.
			expandVal, marks := expandVal.Unmark()
			newArgs := make([]hclsyntax.Expression, 0, (len(args)-1)+expandVal.LengthInt())
			newArgs = append(newArgs, args[:len(args)-1]...)
			it := expandVal.ElementIterator()
			for it.Next() {
				_, val := it.Element()
				newArgs = append(newArgs, &hclsyntax.LiteralValueExpr{
					Val:      val.WithMarks(marks),
					SrcRange: expandExpr.Range(),
				})
			}
			args = newArgs
		default:
			diags = append(diags, &hcl.Diagnostic{
				Severity:    hcl.DiagError,
				Summary:     "Invalid expanding argument value",
				Detail:      "The expanding argument (indicated by ...) must be of a tuple, list, or set type.",
				Subject:     expandExpr.Range().Ptr(),
				Context:     e.Range().Ptr(),
				Expression:  expandExpr,
				EvalContext: ctx,
				Extra:       &diagExtra,
			})
			return cty.DynamicVal, diags
		}
	}

	if len(args) < len(params) {
		missing := params[len(args)]
		qual := ""
		if varParam != nil {
			qual = " at least"
		}
		return cty.DynamicVal, hcl.Diagnostics{
			{
				Severity: hcl.DiagError,
				Summary:  "Not enough function arguments",
				Detail: fmt.Sprintf(
					"Function %q expects%s %d argument(s). Missing value for %q.",
					e.Name, qual, len(params), missing.Name,
				),
				Subject:     &e.CloseParenRange,
				Context:     e.Range().Ptr(),
				Expression:  e,
				EvalContext: ctx,
				Extra:       &diagExtra,
			},
		}
	}

	if varParam == nil && len(args) > len(params) {
		return cty.DynamicVal, hcl.Diagnostics{
			{
				Severity: hcl.DiagError,
				Summary:  "Too many function arguments",
				Detail: fmt.Sprintf(
					"Function %q expects only %d argument(s).",
					e.Name, len(params),
				),
				Subject:     args[len(params)].StartRange().Ptr(),
				Context:     e.Range().Ptr(),
				Expression:  e,
				EvalContext: ctx,
				Extra:       &diagExtra,
			},
		}
	}

	argVals := make([]cty.Value, len(args))

	for i, argExpr := range args {
		var param *function.Parameter
		if i < len(params) {
			param = &params[i]
		} else {
			param = varParam
		}

		var val cty.Value
		if decodeFn := customdecode.CustomExpressionDecoderForType(param.Type); decodeFn != nil {
			var argDiags hcl.Diagnostics
			val, argDiags = decodeFn(argExpr, ctx)
			diags = append(diags, argDiags...)
			if val == cty.NilVal {
				val = cty.UnknownVal(param.Type)
			}
		} else {
			var argDiags hcl.Diagnostics
			val, argDiags = argExpr.Value(ctx)
			if len(argDiags) > 0 {
				diags = append(diags, argDiags...)
			}

			// Try to convert our value to the parameter type
			var err error
			val, err = convert.Convert(val, param.Type)
			if err != nil {
				diags = append(diags, &hcl.Diagnostic{
					Severity: hcl.DiagError,
					Summary:  "Invalid function argument",
					Detail: fmt.Sprintf(
						"Invalid value for %q parameter: %s.",
						param.Name, err,
					),
					Subject:     argExpr.StartRange().Ptr(),
					Context:     e.Range().Ptr(),
					Expression:  argExpr,
					EvalContext: ctx,
					Extra:       &diagExtra,
				})
			}
		}

		argVals[i] = val
	}

	if diags.HasErrors() {
		// Don't try to execute the function if we already have errors with
		// the arguments, because the result will probably be a confusing
		// error message.
		return cty.DynamicVal, diags
	}

	resultVal, err := f.Call(argVals)
	if err != nil {
		// For errors in the underlying call itself we also return the raw
		// call error via an extra method on our "diagnostic extra" value.
		diagExtra.functionCallError = err

		switch terr := err.(type) {
		case function.ArgError:
			i := terr.Index
			var param *function.Parameter
			if i < len(params) {
				param = &params[i]
			} else {
				param = varParam
			}

			if param == nil || i > len(args)-1 {
				// Getting here means that the function we called has a bug:
				// it returned an arg error that refers to an argument index
				// that wasn't present in the call. For that situation
				// we'll degrade to a less specific error just to give
				// some sort of answer, but best to still fix the buggy
				// function so that it only returns argument indices that
				// are in range.
				switch {
				case param != nil:
					// In this case we'll assume that the function was trying
					// to talk about a final variadic parameter but the caller
					// didn't actually provide any arguments for it. That means
					// we can at least still name the parameter in the
					// error message, but our source range will be the call
					// as a whole because we don't have an argument expression
					// to highlight specifically.
					diags = append(diags, &hcl.Diagnostic{
						Severity: hcl.DiagError,
						Summary:  "Invalid function argument",
						Detail: fmt.Sprintf(
							"Invalid value for %q parameter: %s.",
							param.Name, err,
						),
						Subject:     e.Range().Ptr(),
						Expression:  e,
						EvalContext: ctx,
						Extra:       &diagExtra,
					})
				default:
					// This is the most degenerate case of all, where the
					// index is out of range even for the declared parameters,
					// and so we can't tell which parameter the function is
					// trying to report an error for. Just a generic error
					// report in that case.
					diags = append(diags, &hcl.Diagnostic{
						Severity: hcl.DiagError,
						Summary:  "Error in function call",
						Detail: fmt.Sprintf(
							"Call to function %q failed: %s.",
							e.Name, err,
						),
						Subject:     e.StartRange().Ptr(),
						Context:     e.Range().Ptr(),
						Expression:  e,
						EvalContext: ctx,
						Extra:       &diagExtra,
					})
				}
			} else {
				argExpr := args[i]

				// TODO: we should also unpick a PathError here and show the
				// path to the deep value where the error was detected.
				diags = append(diags, &hcl.Diagnostic{
					Severity: hcl.DiagError,
					Summary:  "Invalid function argument",
					Detail: fmt.Sprintf(
						"Invalid value for %q parameter: %s.",
						param.Name, err,
					),
					Subject:     argExpr.StartRange().Ptr(),
					Context:     e.Range().Ptr(),
					Expression:  argExpr,
					EvalContext: ctx,
					Extra:       &diagExtra,
				})
			}

		default:
			diags = append(diags, &hcl.Diagnostic{
				Severity: hcl.DiagError,
				Summary:  "Error in function call",
				Detail: fmt.Sprintf(
					"Call to function %q failed: %s.",
					e.Name, err,
				),
				Subject:     e.StartRange().Ptr(),
				Context:     e.Range().Ptr(),
				Expression:  e,
				EvalContext: ctx,
				Extra:       &diagExtra,
			})
		}

		return cty.DynamicVal, diags
	}

	return resultVal, diags
}
